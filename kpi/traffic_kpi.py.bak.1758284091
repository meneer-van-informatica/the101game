from flask import Flask, request, jsonify, make_response, Response
import time, threading, uuid, re, os
from datetime import datetime, timezone

app = Flask(__name__)

# ===== CONFIG (v3) =====================================================================
TTL_SECONDS   = 90            # failsafe presence
ROUND_SECONDS = 60            # reset iedereen elke 60s
CODE_RE = re.compile(r"^[A-Z]{4}$")

_sessions = {}   # sid -> {"last_seen": float, "joined_at": float, "code": str|None}
_lock = threading.Lock()
_rev = 1
_round_started = time.time()

# helpers
_now   = time.time
def _iso(ts): return datetime.fromtimestamp(ts, tz=timezone.utc).isoformat(timespec="seconds")
def _sweep(now=None):
    now = now or _now()
    dead = [sid for sid,d in list(_sessions.items()) if now - d.get("last_seen", 0) > TTL_SECONDS]
    for sid in dead: _sessions.pop(sid, None)
def _active_count(now=None):
    now = now or _now()
    return sum(1 for d in _sessions.values() if now - d.get("last_seen", 0) <= TTL_SECONDS)
def _get_or_create_session(sid, now=None):
    now = now or _now()
    s = _sessions.get(sid)
    if not s:
        s = {"last_seen": now, "joined_at": now, "code": None}
        _sessions[sid] = s
    return s
def _tleft(now=None):
    now = now or _now()
    left = ROUND_SECONDS - int(now - _round_started)
    return max(0, left)
def _mmss(sec):
    m, s = divmod(max(0,int(sec)), 60)
    return f"{m:02d}:{s:02d}"

# janitor: ronde-reset
def _janitor():
    global _round_started, _rev
    while True:
        time.sleep(1)
        now = _now()
        with _lock:
            if now - _round_started >= ROUND_SECONDS:
                _sessions.clear()
                _round_started = now
                _rev += 1
            else:
                _sweep(now)
threading.Thread(target=_janitor, daemon=True).start()

# ===== API (pulse/board/join/leave/round) ==============================================
@app.route("/kpi/pulse", methods=["POST","GET"])
def pulse():
    sid = request.cookies.get("sid") or uuid.uuid4().hex
    now = _now()
    with _lock:
        s = _get_or_create_session(sid, now)
        s["last_seen"] = now
        cnt = _active_count(now)
        rev = _rev
        tleft = _tleft(now)
    res = make_response(jsonify({"count": cnt, "sid": sid, "ttl": TTL_SECONDS, "rev": rev, "tleft": tleft}))
    res.set_cookie("sid", sid, max_age=86400, secure=True, httponly=False, samesite="Lax")
    res.headers["Cache-Control"] = "no-store"
    return res

@app.post("/kpi/join")
def join():
    code = (request.form.get("code") if request.form else None) or (request.json or {}).get("code", None)
    if not code or not CODE_RE.match(code):
        return jsonify({"ok": False, "error": "CODE_INVALID", "hint": "4 hoofdletters [A-Z]."}), 400
    sid = request.cookies.get("sid") or uuid.uuid4().hex
    now = _now()
    with _lock:
        s = _get_or_create_session(sid, now)
        s.update(code=code, joined_at=now, last_seen=now)
        cnt = _active_count(now)
        rev = _rev
        tleft = _tleft(now)
    res = make_response(jsonify({"ok": True, "sid": sid, "code": code, "count": cnt, "rev": rev, "tleft": tleft}))
    res.set_cookie("sid", sid, max_age=86400, secure=True, httponly=False, samesite="Lax")
    res.headers["Cache-Control"] = "no-store"
    return res

@app.post("/kpi/leave")
def leave():
    sid = request.cookies.get("sid")
    with _lock:
        if sid: _sessions.pop(sid, None)
    return jsonify({"ok": True})

@app.get("/kpi/board")
def board():
    now = _now()
    with _lock:
        items = []
        for sid, d in _sessions.items():
            if now - d.get("last_seen", 0) > TTL_SECONDS: continue
            code = d.get("code")
            if not code: continue
            age = int(now - d.get("joined_at", now))
            items.append({"code": code, "age_s": age})
        items.sort(key=lambda x: (-x["age_s"], x["code"]))
        rev = _rev
        tleft = _tleft(now)
    return jsonify({"board": items, "count": len(items), "rev": rev, "tleft": tleft})

@app.get("/kpi/round")
def round_info():
    with _lock:
        return jsonify({"tleft": _tleft(), "rev": _rev, "round": ROUND_SECONDS})

# ===== KISS: /kpi/screen.txt → pure ASCII payload ======================================
def _ascii_screen(cols=160, rows=144):
    now = _now()
    with _lock:
        cnt = _active_count(now)
        tleft = _tleft(now)
        # sorted board (same as /kpi/board)
        entries = []
        for sid, d in _sessions.items():
            if now - d.get("last_seen", 0) > TTL_SECONDS: continue
            if not d.get("code"): continue
            entries.append((d["code"], int(now - d.get("joined_at", now))))
        entries.sort(key=lambda x: (-x[1], x[0]))

    # frame
    if cols < 2 or rows < 2:
        return "invalid size\n"
    lines = [""] * rows
    horiz = "-" * (cols - 2)
    lines[0] = "+" + horiz + "+"
    lines[rows-1] = "+" + horiz + "+"
    middle = " " * (cols - 2)
    for r in range(1, rows-1):
        lines[r] = "|" + middle + "|"

    def put(x, y, s):
        if not (0 < x < cols-1 and 0 < y < rows-1): return
        s = str(s)[:max(0, cols-1-x)]
        row = lines[y]
        lines[y] = row[:x] + s + row[x+len(s):]

    put(2, 2, f"TRAFFIC: {cnt:05d}   ROUND T-{_mmss(tleft)}")
    put(2, 3, "ALIAS   TIME")

    y = 5
    for i, (code, age) in enumerate(entries):
        if y >= rows-1: break
        line = f"{i+1:2d}. {code}   {_mmss(age)}"
        put(2, y, line)
        y += 1

    return "\n".join(lines) + "\n"

@app.get("/kpi/screen.txt")
def screen_txt():
    body = _ascii_screen()
    r = Response(body, mimetype="text/plain; charset=utf-8")
    r.headers["Cache-Control"] = "no-store"
    return r

# ===== Minimal viewer (optioneel): /kpi/screen ==========================================
@app.get("/kpi/screen")
def screen_html():
    # superlichte HTML die elke seconde /kpi/screen.txt ophaalt + één alias-modal
    html = """
<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>the101game — ASCII</title>
<style>
  html,body{margin:0;background:#000;color:#0f0}
  pre{margin:0;white-space:pre;line-height:1;letter-spacing:0;font:12px ui-monospace,monospace}
  #wrap{padding:6px}
  #alias{position:fixed;inset:0;display:none;place-items:center;background:#000c}
  #card{background:#000;border:1px solid #0f0;padding:10px;color:#0f0}
  input,button{background:#000;border:1px solid #0f0;color:#0f0;font:700 16px ui-monospace,monospace}
  input{letter-spacing:.2em;text-transform:uppercase;padding:6px}
  button{padding:6px 10px;margin-left:8px}
</style>
<div id="wrap"><pre id="scr"></pre></div>
<div id="alias"><div id="card"><div>ALIAS (4 hoofdletters):</div><div style="margin-top:6px"><input id="code" maxlength="4"><button id="ok">JOIN</button></div></div></div>
<script>
  const scr=document.getElementById('scr'), modal=document.getElementById('alias'), codeIn=document.getElementById('code'), ok=document.getElementById('ok');
  function needAlias(){ return !/^[A-Z]{4}$/.test(localStorage.getItem('kpiCode')||''); }
  function showAlias(){ modal.style.display='grid'; codeIn.value=''; codeIn.focus(); }
  ok.addEventListener('click', async ()=>{
    const v=(codeIn.value||'').toUpperCase().replace(/[^A-Z]/g,'').slice(0,4);
    if(!/^[A-Z]{4}$/.test(v)){ codeIn.focus(); return; }
    try{
      const r = await fetch('/kpi/join',{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:'code='+encodeURIComponent(v)});
      if(!r.ok) throw 0; localStorage.setItem('kpiCode',v); modal.style.display='none';
    }catch(_){}
  });
  async function tick(){
    try{
      const t = await fetch('/kpi/screen.txt',{cache:'no-store'}).then(r=>r.text());
      scr.textContent = t;
    }catch(_){}
  }
  if(needAlias()) showAlias();
  tick(); setInterval(tick, 1000);
</script>
"""
    return Response(html, mimetype="text/html; charset=utf-8")
