from flask import Flask, request, jsonify, make_response, Response
import time, threading, uuid, re, os
from datetime import datetime, timezone

app = Flask(__name__)

# ====== CONFIG ========================================================================
TTL_SECONDS   = 90            # presence fallback; groter dan ronde (60) om tussen pulses niet te droppen
ROUND_SECONDS = 60            # *** reset iedereen elke 60s ***
CODE_RE = re.compile(r"^[A-Z]{4}$")

# State
_sessions = {}   # sid -> {"last_seen": float, "joined_at": float, "code": str|None}
_lock = threading.Lock()
_rev = 1
_round_started = time.time()

def _now(): return time.time()
def _iso(ts): return datetime.fromtimestamp(ts, tz=timezone.utc).isoformat(timespec="seconds")

def _sweep(now=None):
    if now is None: now = _now()
    dead = [sid for sid, d in list(_sessions.items()) if now - d.get("last_seen", 0) > TTL_SECONDS]
    for sid in dead: _sessions.pop(sid, None)

def _active_count(now=None):
    if now is None: now = _now()
    return sum(1 for d in _sessions.values() if now - d.get("last_seen", 0) <= TTL_SECONDS)

def _get_or_create_session(sid, now=None):
    if now is None: now = _now()
    s = _sessions.get(sid)
    if not s:
        s = {"last_seen": now, "joined_at": now, "code": None}
        _sessions[sid] = s
    return s

def _round_seconds_left(now=None):
    if now is None: now = _now()
    left = ROUND_SECONDS - int(now - _round_started)
    return max(0, left)

# Janitor: elke seconde checkt of ronde voorbij is → reset, bump rev
def _janitor():
    global _round_started, _rev
    while True:
        time.sleep(1)
        now = _now()
        with _lock:
            if now - _round_started >= ROUND_SECONDS:
                _sessions.clear()
                _round_started = now
                _rev += 1
            else:
                _sweep(now)

threading.Thread(target=_janitor, daemon=True).start()

# ====== KPI: pulse / read / compat =====================================================
from flask import request, jsonify, make_response, Response

@app.route("/kpi/pulse", methods=["POST","GET"])
def pulse():
    sid = request.cookies.get("sid") or uuid.uuid4().hex
    now = _now()
    with _lock:
        s = _get_or_create_session(sid, now)
        s["last_seen"] = now
        cnt = _active_count(now)
        rev = _rev
        tleft = _round_seconds_left(now)
    res = make_response(jsonify({"count": cnt, "sid": sid, "ttl": TTL_SECONDS, "rev": rev, "tleft": tleft}))
    res.set_cookie("sid", sid, max_age=86400, secure=True, httponly=False, samesite="Lax")
    res.headers["Cache-Control"] = "no-store"
    return res

@app.get("/kpi/traffic/read")
def traffic_read():
    with _lock:
        cnt = _active_count()
    if request.args.get("json"):
        return jsonify({"count": cnt, "ttl": TTL_SECONDS})
    body = f"the101game — Traffic KPI\nDit is tijdelijk de enige live feature.\nTraffic: {str(cnt).zfill(5)} live\n"
    return Response(body, mimetype="text/plain")

@app.get("/kpi/traffic")
def traffic_compat():
    with _lock:
        cnt = _active_count()
    return jsonify({"count": cnt})

# ====== KPI #2: alias + board ==========================================================
@app.post("/kpi/join")
def join():
    code = (request.form.get("code") if request.form else None) or (request.json or {}).get("code", None)
    if not code or not CODE_RE.match(code):
        return jsonify({"ok": False, "error": "CODE_INVALID", "hint": "4 hoofdletters [A-Z]."}), 400
    sid = request.cookies.get("sid") or uuid.uuid4().hex
    now = _now()
    with _lock:
        s = _get_or_create_session(sid, now)
        s["code"] = code
        s["joined_at"] = now
        s["last_seen"] = now
        cnt = _active_count(now)
        rev = _rev
        tleft = _round_seconds_left(now)
    res = make_response(jsonify({"ok": True, "sid": sid, "code": code, "count": cnt, "rev": rev, "tleft": tleft}))
    res.set_cookie("sid", sid, max_age=86400, secure=True, httponly=False, samesite="Lax")
    res.headers["Cache-Control"] = "no-store"
    return res

@app.post("/kpi/leave")
def leave():
    sid = request.cookies.get("sid")
    with _lock:
        if sid: _sessions.pop(sid, None)
    return jsonify({"ok": True})

@app.get("/kpi/board")
def board():
    now = _now()
    with _lock:
        items = []
        for sid, d in _sessions.items():
            if now - d.get("last_seen", 0) > TTL_SECONDS: continue
            code = d.get("code")
            if not code: continue
            age = int(now - d.get("joined_at", now))
            items.append({"code": code, "age_s": age})
        items.sort(key=lambda x: (-x["age_s"], x["code"]))
        rev = _rev
        tleft = _round_seconds_left(now)
    return jsonify({"board": items, "count": len(items), "rev": rev, "tleft": tleft})

@app.get("/kpi/round")
def round_info():
    with _lock:
        tleft = _round_seconds_left()
        rev = _rev
    return jsonify({"tleft": tleft, "rev": rev, "round": ROUND_SECONDS})
